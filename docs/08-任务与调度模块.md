# 任务与调度模块

## 组件概览
- 仓储层：`internal/repository/task_repository.go`
- HTTP 接口：`internal/handler/task_handler.go`
- 任务模型：`internal/model/task.go`
- 队列客户端与 Worker：`pkg/queue/{client.go,worker.go,task.go}`
- 定时调度器：`pkg/scheduler/scheduler.go`
- 配置项：`config.queue`、`config.ratelimit`（限流与任务统计可配合使用）

## 数据模型与仓储
- 数据表 `tasks` 记录后台任务执行情况，字段包括：`task_id`（业务 ID）、`type`、`status`、重试次数、错误信息等。
- 仓储方法提供按状态、类型、用户的分页查询，以及 `UpdateStatus`、`CountByStatus` 等统计能力。
- 该表可用于追踪异步任务处理进度，或为后台任务中心提供数据支持。

## REST 接口
`TaskHandler` 直接依赖仓储暴露只读接口，适合后台面板查看：
- `GET /api/v1/tasks`：按状态或类型分页查询（默认过滤 `pending`）。
- `GET /api/v1/tasks/:id`：通过数据库自增 ID 获取详情。
- `GET /api/v1/tasks/task/:taskId`：以业务自定义 `task_id` 查询。
- `GET /api/v1/tasks/stats`：统计 pending/processing/success/failed 数量，便于仪表盘展示。

## 队列系统
### 总体架构
- 采用 Redis 作为存储，实现轻量级任务队列与延迟队列。
- `QueueClient` 负责投递任务：
  - `Submit`：即时任务推入 `prefix:tasks` 列表。
  - `SubmitIn`：延迟任务写入 `prefix:delayed_tasks` 的有序集合，按执行时间排序。
  - 所有任务序列化为 `QueueTask`（包含 ID、名称、载荷、最大重试次数等）。
- `Worker` 管理多个消费协程：
  - `Register` 为任务名称绑定处理函数。
  - `Start` 创建指定数量 Worker 并启动延迟调度器。
  - `work` 协程使用 `BRPOP` 阻塞获取任务，解码后执行对应 handler。
  - 失败重试：若 `RetryCount < MaxRetry`，按照配置的 `retry_delay` 重新入队；任务状态写回 `tasks` 表仍需在业务 handler 内显式处理。
  - `scheduleDelayedTasks` 周期性扫描延迟队列，将到期任务迁移至主队列。
  - `Stats` 返回 Worker 数量、队列长度、重试策略等信息，可用于健康监控。

### 配置说明
`config.queue` 提供以下参数：
- `enabled`：是否启用队列 Worker。
- `workers`：并发 Worker 数量。
- `max_retry`、`retry_delay`：重试策略。
- `redis_prefix`：Redis 键名前缀，便于多环境隔离。
- `poll_interval`：延迟队列轮询频率（当前实现固定 5 秒，可根据需要拓展）。

## 定时调度器
- `pkg/scheduler` 基于 `robfig/cron` 二次封装，支持秒级精度。
- 提供 `AddFunc`、`AddInterval`、`AddJob` 三种添加方式，并内置日志记录执行耗时。
- `Start`/`Stop` 控制调度器生命周期，`Stats` 可产出所有任务的下一次/上一次执行时间。
- 在应用启动阶段，可初始化 Scheduler，注册周期性任务（如清理过期文件、同步第三方数据等），并将结果写入 `tasks` 表或其他观察通道。

## 典型流程示例
1. **投递任务**：业务代码调用 `queue.NewClient(prefix).Submit(ctx, "send_email", payload, 3)`，返回 `task_id`。
2. **执行任务**：Worker 发现新任务后触发 `send_email` 处理函数，成功则记录日志，失败则按重试策略再入队。
3. **状态落库**：业务必须在 handler 内更新 `tasks` 表中的状态和错误信息；即便队列发生重试，框架不会自动同步数据库记录，需要自行决定是覆盖还是追加历史记录。
4. **定时任务**：使用 Scheduler 注册 `@every 1h` 任务，把巡检结果写入任务队列表，统一在任务中心展示。

## 扩展建议
1. **统一任务服务层**：引入 Service 将队列投递、状态落库封装在一起，避免各业务重复实现。
2. **Worker 监控**：结合 Prometheus 暴露执行成功/失败数量、队列长度，实现告警。
3. **任务路由**：Worker 支持按名称分组，将不同任务调度到独立的 Worker 集群。
4. **可视化控制**：在后台面板增加重试/取消操作，通过仓储暴露的 `UpdateStatus` 实现人工干预。
5. **幂等保障**：在 handler 内根据任务 ID 做幂等校验，防止重复消费带来的数据问题。

掌握该模块可以快速构建异步任务、延迟任务和定时任务体系，为邮件通知、报表生成等后台工作流提供基础能力。